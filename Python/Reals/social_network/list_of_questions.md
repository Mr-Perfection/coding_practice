Closest Ancestor in Binary Tree (Leetcode 235,236) ???
<!-- Regular Expression Matching (Leetcode 10)  -->
<!-- – Given a string and a pattern ‘.’ Matches any single character. ‘*’ Matches zero or more of the preceding element.), find the first substring matching this pattern. -->
<!-- Sum of Subarray (DFS) -->
<!-- – For an array of non-negative integer numbers, and a target number, determine whether there’s a subarray whose sum equals to target number -->
<!-- Longest Common Subsequence -->
 https://www.hackerrank.com/challenges/dynamic-programming-classics-the-longest-common-subsequence
Convert a binary search tree to a circularly doubly linked list. Operate only on trees.
<!-- Binary Tree Iterator (Leetcode 173) -->
<!-- 3Sums (Leetcode 15) -->
<!-- Big Number Multiplications / Additions (Leetcode 43) -->
If A = 1, B = 2, etc., Z = 26, output all the possible combinations of a string of numbers (ie. 123 could be “abc” or “ic” or “aw”)
Copy List With Random Pointer (Leetcode 138)
Binary Tree Paths using both iterative and recursive ways (Leetcode 257)
Given a set of strings, return the smallest subset that contains prefixes for every string. If the list is [‘foo’, ‘foog’, ‘food’, ‘asdf’] return [‘foo’, ‘asdf’]
Print tree columnwisely
Give a dictionary with a huge set of words and a string with wildcard. You are required to find whether there is a match in the dictionary for this given string. (Trie)
Count and Say (Leetcode 38)
TwoSum (Leetcode 1, 167, 170)
Move Zeros (Leetcode 283)
Find largest element in non transitive sequence of elements, i.e., A > C && C > B doesn’t imply A > B, O(n) solution (Leetcode 277)
Convert from decimal to roman and vice versa (Leetcode 12-13)
Function to find the square/cubic root of a number (Leetcode 69)
Find the minimum editing distance between two words (Leetcode 161)
Celebrity (Leetcode 277)
Design a system to detect homeworking copying, which means input two strings and a integer K, if there is a common substring of them have length larger than K, return true, else return false (Trie / Suffix Tree)
Find the intersection of two sorted arrays (binary search or merge sort)
reverse double linked list
heap implementation
implement division without +, – or multiplication (Leetcode 29)
reverse integer (Leetcode 7)
clone graph (Leetcode 133)
There is two dimensional array where each sub array (row) is sorted, i.e. [[1 1000 2000] [20 1001 5000] [55 1002 222222]]
Find a minimum range contain a number from each row. For above array it should be (1000-1002) range. (Merge Sort)
Given an array of numbers, they are arranged so that the a[0] is in the 1st bucket, a[1]a[2] are in the 2nd bucket, a[3]a[4]a[5] is in the 3rd bucket and so on.
All the numbers in one bucket are larger than that of the previous bucket. So ALL numbers of bucket 3 will be bigger than ANY number of the bucket 2 and so on.
The number given to the function may or may not be in the array.
The question is then: given a number, you need to return if it is in any bucket (Binary search)
Given a set of n jobs with [start time, end time, cost] find a subset so that no 2 jobs overlap and the cost is maximum (Depth-first Search).
Write a function to compute Hamming distance between two numbers.
Followup, write a function that takes a list of integers and returns the sum of the hamming distance for each pair. The optimal solution should be O(n).
Given an array of distinct integers, and a target integer t, compute all of the subsets of the array that sum to t.
Smallest missing natural number in a linked list in linear time without a hash table
You are given an integer N and an integer M. You are supposed to write a method void findBestCoinsThatMinimizeAverage(int N, int M) that prints the best collection of N coins
that minimize the average number of minimum coins needed to generate values from 1 to M. So, if M = 100, and N = 4, then if we use the set {1, 5, 10, 25} to generate each value
from 1 to 100, so that for each value the number of coins are minimized, i.e. 1 = 1 (1 coin), 2 = 1 + 1 (2 coins),…, 6 = 1 + 5 (2 coins), …, 24 = 5 + 5 + 5 + 5 + 1 + 1 + 1 + 1 (8 coins),
and we take the average of these coins, we would see that the average comes out to ~5.7. But if we instead use {1, 5, 18, 25}, the average would come out to be 3.7.
We are to find that set of N coins, and print them, that produce the minimum average. (NP-Hard)
Given a list of n integers, write a function that outputs the minimum subset of numbers that sum to at least K. FOLLOW UP: can you beat O(n ln n)? (Selection Algorithm)
Write a function that computes log2() using sqrt(). (Math)
Given an array of integers and a target number, find the two elements whose sum is closest to the target number.
You have two lists with meetings scheduling (start time, end time) Meetings in single list don’t intersect. Find all intersecting meetings across the two lists. (Merge sort – ending time)
Longest common substring (Dynamic Programming / Generalized Suffix Tree)
https://en.wikipedia.org/wiki/Longest_common_substring_problem
Find the successor/predecessor of a binary search tree. (Leetcode 173 Similar)
Given a m*n grid starting from (1, 1). At any point (x, y), you has two choices for the next move: 1) move to (x+y, y); 2) move to (x, y+x);
From point (1, 1), how to move to (m, n) in least moves? (or there’s no such a path) (Breath-first Search, Similar to Leetcdoe 45 Jump Game II)
Given sorted arrays of length n and 2n with n elements each, merge first array into second array. (Merge Sort from the largest)
Implement stack using a queue / implement queue using stack
